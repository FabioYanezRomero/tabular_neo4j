import argparse
import json
import os
from collections import defaultdict
from typing import Dict, List, Any

try:
    import yaml  # type: ignore
except ImportError:
    raise SystemExit("PyYAML is required. Install with `pip install pyyaml`.")


def load_state(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def build_entity_mapping(state: Dict[str, Any]) -> Dict[str, str]:
    """Return mapping of original label -> merged label (identity if unchanged)."""
    mapping: Dict[str, str] = {}
    merges = state.get("entity_label_merges", {}).get("merges", [])
    for merge in merges:
        to_labels = merge.get("to", [])
        if len(to_labels) != 1:
            # Currently only supporting 1-to-1 merges; keep first if multiple
            target = to_labels[0] if to_labels else None
        else:
            target = to_labels[0]
        if not target:
            continue
        for src in merge.get("from", []):
            mapping[src] = target
    return mapping


def collect_properties_and_labels(state: Dict[str, Any], label_map: Dict[str, str]) -> Dict[str, List[str]]:
    # Prefer property unions generated by LLM if present
    unions = state.get("entity_property_unions", {}).get("entities", {}) or {}

    props_by_label: Dict[str, set] = defaultdict(set)
    all_labels: set[str] = set(unions.keys())

    for tbl_state in state.values():
        if not isinstance(tbl_state, dict):
            continue
        col_map = tbl_state.get("column_graph_mapping", {}) or {}
        for col_name, mapping in col_map.items():
            if mapping.get("graph_element_type") != "entity_property":
                continue
            lbl = mapping.get("belongs_to") or ""
            if not lbl:
                continue
            lbl_final = label_map.get(lbl, lbl)
            all_labels.add(lbl_final)
            # If unions already provide properties for this label, skip aggregation to avoid duplicates
            if lbl_final in unions:
                continue
            props_by_label[lbl_final].add(col_name)

    # Combine unions (preferred) with aggregated props
    combined: Dict[str, List[str]] = {}
    for lbl in all_labels:
        if lbl in unions:
            combined[lbl] = sorted(unions[lbl])
        else:
            combined[lbl] = sorted(list(props_by_label.get(lbl, set())))
    return combined


def collect_relationships(state: Dict[str, Any], label_map: Dict[str, str]) -> List[Dict[str, str]]:
    rels: List[Dict[str, str]] = []
    for tbl_state in state.values():
        if not isinstance(tbl_state, dict):
            continue
        intra = tbl_state.get("intra_table_entity_relations", {}) or {}
        for rel in intra.get("entity_relationships", []):
            src = label_map.get(rel.get("source_entity"), rel.get("source_entity"))
            tgt = label_map.get(rel.get("target_entity"), rel.get("target_entity"))
            rels.append({
                "type": rel.get("relationship_type"),
                "source": src,
                "target": tgt,
            })
    # Deduplicate
    unique = {(r["source"], r["type"], r["target"]): r for r in rels}
    return list(unique.values())


def generate_yaml_schema(state: Dict[str, Any]) -> Dict[str, Any]:
    label_map = build_entity_mapping(state)
    node_props = collect_properties_and_labels(state, label_map)
    relationships = collect_relationships(state, label_map)

    # Convert to golden-style structure
    nodes: List[Dict[str, Any]] = []
    for lbl in sorted(node_props.keys()):
        nodes.append({
            "type": lbl.lower() if lbl.isupper() else lbl,  # keep simple, can adjust
            "attributes": node_props[lbl] or [],
        })
    edges: List[Dict[str, Any]] = []
    for rel in sorted(relationships, key=lambda r: (r["type"], r["source"], r["target"])):
        edge_obj: Dict[str, Any] = {
            "type": rel["type"],
            "source": rel["source"].lower() if rel["source"].isupper() else rel["source"],
            "target": rel["target"].lower() if rel["target"].isupper() else rel["target"],
        }
        # relationship attributes placeholder â€“ will be filled if present in state in future
        rel_props = state.get("relationship_property_mappings", {}).get(rel["type"], [])
        if rel_props:
            edge_obj["attributes"] = sorted(rel_props)
        edges.append(edge_obj)

    return {
        "nodes": nodes,
        "edges": edges,
    }


def main(final_state_path: str | None = None):
    if final_state_path is None:
        parser = argparse.ArgumentParser(description="Generate YAML graph schema from final_state.json")
        parser.add_argument("final_state", help="Path to final_state.json")
        args = parser.parse_args()
        final_state_path = args.final_state

    state = load_state(final_state_path)
    schema = generate_yaml_schema(state)

    output_dir = "/app/schemas/generated"
    os.makedirs(output_dir, exist_ok=True)
    # Use the *timestamp* folder (three levels up: samples/<timestamp>/GLOBAL/...) for the filename
    timestamp_folder = os.path.basename(os.path.dirname(os.path.dirname(os.path.dirname(final_state_path))))
    out_path = os.path.join(output_dir, f"{timestamp_folder}_schema.yaml")
    with open(out_path, "w", encoding="utf-8") as f:
        yaml.safe_dump(schema, f, sort_keys=False, default_flow_style=False, allow_unicode=True)
    print(f"Schema written to {out_path}")


if __name__ == "__main__":
    main("/app/samples/20250715_183522/GLOBAL/GLOBAL/final_state.json")
