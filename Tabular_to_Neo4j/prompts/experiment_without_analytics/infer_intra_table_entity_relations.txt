You are a data-modeling expert. Your task is to infer **intra-table** relationships between the entities present in the following table.

### Input
- **Table name**: `{table_name}`
- **Detected entities**: {entities}
- **Columns Sample (up to 5 rows)**:
  ```
  {columns_sample}
  ```

### Instructions
1. For every meaningful relationship that can be deduced between two *different* entities in this single table, identify:
 • `source_entity` – which entity the relation starts from.
 • `target_entity` – which entity it points to.
 • `relationship_type` – domain-specific lower-snake-case verb phrase that reflects the table's business context and column characteristics (e.g., `purchased_by`, `assigned_to`, `managed_by`, `belongs_to_category`).
 • `direction` – one of `source_to_target`, `target_to_source` or `undirected`.
 • `confidence` – number 0-1.
 • `reasoning` – Justification for the relationship.
2. Use the **table name** and **column sample** to infer domain-specific relationship semantics rather than generic ones.
3. Consider column characteristics: high uniqueness suggests identifier/ownership relations, low cardinality suggests classification/grouping relations, missing percentages indicate optional relationships.
4. If no clear relationship exists, return an empty array.
5. Keep reasoning concise (≤ 60 words per relationship).

### Output format
Return **only** a valid JSON object of the form:
```json
{
  "entity_relationships": [
    {
      "source_entity": "Customer",
      "target_entity": "Order",
      "relationship_type": "placed_order",
      "direction": "source_to_target",
      "confidence": 0.92,
      "reasoning": "Brief justification (≤60 words)"
    }
    // repeat objects as needed
  ]
}
```


Constraints:
- Do not include properties or any text outside the single JSON object.
- Omit duplicate or trivial self-relationships.
- Focus on domain-specific relationship types that reflect the table's data context.
